# profession_roadmap_agent.py
import logging
import uuid
import json
from typing import Optional, Dict, Any

from openai import AsyncOpenAI

from src.agent.settings import get_config
from src.agent.core.prompts import PromptLoader

logging.basicConfig(
    level=logging.INFO,
    encoding="utf-8",
    format="%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()],
)

config = get_config()


class ProfessionRoadmapAgent:
    """Agent that generates comprehensive career roadmap for a specific profession"""

    name: str = "profession_roadmap_agent"

    def __init__(
        self,
        profession_title: str,
        personality_data: Optional[Dict[str, Any]] = None,
        astrology_data: Optional[Dict[str, Any]] = None,
        current_level: Optional[str] = None,
        model: str = "Qwen/Qwen3-235B-A22B-Instruct-2507",
        max_tokens: Optional[int] = 16384,
        temperature: float = 0.4,
        top_p: float = 0.9,
        presence_penalty: float = 0.0,
        frequency_penalty: float = 0.0,
    ):
        self.id = f"{self.name}_{uuid.uuid4()}"
        self.logger = logging.getLogger(self.id)
        
        self.profession_title = profession_title
        self.personality_data = personality_data
        self.astrology_data = astrology_data
        self.current_level = current_level
        
        self.model = config.model_name if config.model_name else model
        self.max_tokens = max_tokens
        self.temperature = temperature 
        self.top_p = top_p
        self.presence_penalty = presence_penalty
        self.frequency_penalty = frequency_penalty

        client_kwargs = {"base_url": config.base_url.strip(), "api_key": config.api_key}
        self.openai_client = AsyncOpenAI(**client_kwargs)

    def _prepare_input_text(self) -> str:
        """Prepare combined input from profession, personality and astrology data"""
        input_parts = []
        
        # Profession
        input_parts.append(f"=== –¶–ï–õ–ï–í–ê–Ø –ü–†–û–§–ï–°–°–ò–Ø ===")
        input_parts.append(f"–ü—Ä–æ—Ñ–µ—Å—Å–∏—è: {self.profession_title}")
        
        if self.current_level:
            input_parts.append(f"–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å: {self.current_level}")
        
        # Personality data
        if self.personality_data:
            input_parts.append("\n=== –î–ê–ù–ù–´–ï –¢–ï–°–¢–ê –õ–ò–ß–ù–û–°–¢–ò ===")
            input_parts.append(json.dumps(self.personality_data, ensure_ascii=False, indent=2))
        
        # Astrology data
        if self.astrology_data:
            input_parts.append("\n=== –ê–°–¢–†–û–õ–û–ì–ò–ß–ï–°–ö–ò–ô –ü–†–û–§–ò–õ–¨ ===")
            input_parts.append(json.dumps(self.astrology_data, ensure_ascii=False, indent=2))
        
        return "\n".join(input_parts)

    async def generate_roadmap(self) -> Dict[str, Any]:
        """Generate comprehensive career roadmap"""
        self.logger.info(f"üöÄ Starting roadmap generation for: {self.profession_title}")

        system_prompt = PromptLoader.get_prompt("profession_roadmap_prompt.txt")
        input_text = self._prepare_input_text()

        try:
            completion = await self.openai_client.chat.completions.create(
                extra_headers={
                    "HTTP-Referer": config.http_referer,
                    "X-Title": config.x_title,
                },
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {
                        "role": "user",
                        "content": input_text,
                    },
                ],
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                top_p=self.top_p,
                presence_penalty=self.presence_penalty,
                frequency_penalty=self.frequency_penalty,
            )
            
            response_content = completion.choices[0].message.content.strip()
            self.logger.debug(f"Raw response length: {len(response_content)} chars")
            
            # Clean and parse JSON
            cleaned_json = self._clean_json_response(response_content)
            roadmap_data = json.loads(cleaned_json)
            
            # Validate response structure
            if not isinstance(roadmap_data, dict):
                raise ValueError("Response is not a dictionary")
            
            required_fields = ["profession", "overview", "stages"]
            for field in required_fields:
                if field not in roadmap_data:
                    raise ValueError(f"Missing required field: {field}")
            
            # üö® CRITICAL: Ensure interviewQuestions exist in every stage
            roadmap_data = self._ensure_interview_questions(roadmap_data)
            
            self.logger.info(f"‚úÖ Generated roadmap with {len(roadmap_data.get('stages', []))} stages")
            return roadmap_data

        except json.JSONDecodeError as e:
            self.logger.error(f"‚ùå JSON parsing failed: {str(e)}")
            self.logger.error(f"Failed content preview: {response_content[:500]}...")
            raise ValueError(f"Failed to parse AI response as JSON: {str(e)}")
        except Exception as e:
            self.logger.error(f"‚ùå Generation failed: {str(e)}")
            raise

    def _clean_json_response(self, response: str) -> str:
        """Clean response to extract valid JSON"""
        # Remove markdown code blocks if present
        if "```json" in response:
            response = response.split("```json")[1].split("```")[0]
        elif "```" in response:
            response = response.split("```")[1].split("```")[0]
        
        # Strip whitespace
        response = response.strip()
        
        # Fix common text issues that break JSON
        # Replace problematic patterns before JSON parsing
        response = self._sanitize_text_content(response)
        
        # Fix truncated JSON
        return self._fix_truncated_json(response)
    
    def _sanitize_text_content(self, text: str) -> str:
        """Sanitize text content to avoid JSON parsing issues"""
        import re
        
        # Fix unescaped newlines within strings
        text = text.replace('\r\n', ' ').replace('\r', ' ')
        
        # More aggressive backslash fixing
        # First, temporarily mark valid escape sequences
        text = text.replace(r'\"', '\x00QUOTE\x00')
        text = text.replace(r'\\', '\x00BACKSLASH\x00')
        text = text.replace(r'\/', '\x00SLASH\x00')
        text = text.replace(r'\n', '\x00NEWLINE\x00')
        text = text.replace(r'\t', '\x00TAB\x00')
        text = text.replace(r'\r', '\x00RETURN\x00')
        text = text.replace(r'\b', '\x00BACKSPACE\x00')
        text = text.replace(r'\f', '\x00FORMFEED\x00')
        
        # Now escape all remaining backslashes
        text = text.replace('\\', '\\\\')
        
        # Restore valid escape sequences
        text = text.replace('\x00QUOTE\x00', r'\"')
        text = text.replace('\x00BACKSLASH\x00', r'\\')
        text = text.replace('\x00SLASH\x00', r'\/')
        text = text.replace('\x00NEWLINE\x00', r'\n')
        text = text.replace('\x00TAB\x00', r'\t')
        text = text.replace('\x00RETURN\x00', r'\r')
        text = text.replace('\x00BACKSPACE\x00', r'\b')
        text = text.replace('\x00FORMFEED\x00', r'\f')
        
        return text
    
    def _ensure_interview_questions(self, roadmap_data: Dict[str, Any]) -> Dict[str, Any]:
        """Ensure every stage has interviewQuestions field (add fallback if missing)"""
        stages = roadmap_data.get('stages', [])
        
        for i, stage in enumerate(stages):
            if 'interviewQuestions' not in stage or not stage['interviewQuestions']:
                level = stage.get('level', 'UNKNOWN')
                self.logger.warning(f"‚ö†Ô∏è Stage {i+1} ({level}) missing interviewQuestions - adding fallback")
                
                # Add fallback questions based on level
                stage['interviewQuestions'] = self._get_fallback_questions(level, stage.get('title', ''))
        
        return roadmap_data
    
    def _get_fallback_questions(self, level: str, stage_title: str) -> list:
        """Generate fallback interview questions if AI didn't provide them"""
        fallback_questions = {
            'BEGINNER': [
                {
                    "question": "–†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –±–∞–∑–æ–≤—ã—Ö –∫–æ–Ω—Ü–µ–ø—Ü–∏—è—Ö –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏",
                    "answer": "–í–∞–∂–Ω–æ –ø–æ–Ω–∏–º–∞—Ç—å —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã –∏ —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—é. –ù–∞—á–Ω–∏—Ç–µ —Å –æ—Å–Ω–æ–≤ –∏ –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —É–≥–ª—É–±–ª—è–π—Ç–µ—Å—å –≤ –¥–µ—Ç–∞–ª–∏."
                },
                {
                    "question": "–ö–∞–∫–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤—ã —É–∂–µ –∏–∑—É—á–∏–ª–∏ –∏–ª–∏ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ –∏–∑—É—á–∏—Ç—å?",
                    "answer": "–ù–∞ –Ω–∞—á–∞–ª—å–Ω–æ–º —É—Ä–æ–≤–Ω–µ –≤–∞–∂–Ω–æ –æ—Å–≤–æ–∏—Ç—å –±–∞–∑–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ —à–∏—Ä–æ–∫–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –∏–Ω–¥—É—Å—Ç—Ä–∏–∏."
                },
                {
                    "question": "–û–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –ø–µ—Ä–≤—ã–π –ø—Ä–æ–µ–∫—Ç –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏",
                    "answer": "–î–∞–∂–µ –ø—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–µ–∫—Ç –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –ø–æ–Ω–∏–º–∞–Ω–∏–µ –æ—Å–Ω–æ–≤. –†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –∑–∞–¥–∞—á–∞—Ö, —Ä–µ—à–µ–Ω–∏—è—Ö –∏ —á—Ç–æ –≤—ã —É–∑–Ω–∞–ª–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ."
                },
            ],
            'JUNIOR': [
                {
                    "question": "–ö–∞–∫ –≤—ã —Ä–µ—à–∞–µ—Ç–µ —Ç–∏–ø–∏—á–Ω—ã–µ –∑–∞–¥–∞—á–∏ –≤ —Å–≤–æ–µ–π —Ä–∞–±–æ—Ç–µ?",
                    "answer": "–û–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –ø–æ–¥—Ö–æ–¥ –∫ —Ä–µ—à–µ–Ω–∏—é –ø—Ä–æ–±–ª–µ–º, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∏ –º–µ—Ç–æ–¥—ã –æ—Ç–ª–∞–¥–∫–∏."
                },
                {
                    "question": "–†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –ø—Ä–æ–µ–∫—Ç–µ, –Ω–∞–¥ –∫–æ—Ç–æ—Ä—ã–º –≤—ã —Ä–∞–±–æ—Ç–∞–ª–∏",
                    "answer": "–ü–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—à–∏—Ç–µ —Å–≤–æ—é —Ä–æ–ª—å, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ —Ä–∞–±–æ—Ç–∞–ª–∏, –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞."
                },
            ],
            'MIDDLE': [
                {
                    "question": "–ö–∞–∫ –≤—ã –ø—Ä–æ–µ–∫—Ç–∏—Ä—É–µ—Ç–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É —Ä–µ—à–µ–Ω–∏—è?",
                    "answer": "–û–±—ä—è—Å–Ω–∏—Ç–µ —Å–≤–æ–π –ø–æ–¥—Ö–æ–¥ –∫ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–º —Ä–µ—à–µ–Ω–∏—è–º, —É—á–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç–∏ –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç–∏."
                },
                {
                    "question": "–û–ø–∏—à–∏—Ç–µ —Å–ª–æ–∂–Ω—É—é —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é –ø—Ä–æ–±–ª–µ–º—É, –∫–æ—Ç–æ—Ä—É—é –≤—ã —Ä–µ—à–∏–ª–∏",
                    "answer": "–†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –ø—Ä–æ–±–ª–µ–º–µ, –≤–∞—à–µ–º –∞–Ω–∞–ª–∏–∑–µ, –≤—ã–±–æ—Ä–µ —Ä–µ—à–µ–Ω–∏—è –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö."
                },
            ],
            'SENIOR': [
                {
                    "question": "–ö–∞–∫ –≤—ã –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –∫—Ä—É–ø–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤?",
                    "answer": "–û–ø–∏—à–∏—Ç–µ –ø—Ä–æ—Ü–µ—Å—Å –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π, –≤—ã–±–æ—Ä–∞ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π –∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏—è —Ä–µ—à–µ–Ω–∏–π –ø–µ—Ä–µ–¥ –∫–æ–º–∞–Ω–¥–æ–π."
                },
                {
                    "question": "–ö–∞–∫ –≤—ã –º–µ–Ω—Ç–æ—Ä–∏—Ç–µ junior-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤?",
                    "answer": "–†–∞—Å—Å–∫–∞–∂–∏—Ç–µ –æ –≤–∞—à–µ–º –ø–æ–¥—Ö–æ–¥–µ –∫ –æ–±—É—á–µ–Ω–∏—é, code review –∏ —Ä–∞–∑–≤–∏—Ç–∏—é –∫–æ–º–∞–Ω–¥—ã."
                },
            ],
            'EXPERT': [
                {
                    "question": "–ö–∞–∫–∏–µ —Ç—Ä–µ–Ω–¥—ã –≤ –∏–Ω–¥—É—Å—Ç—Ä–∏–∏ –≤—ã —Å—á–∏—Ç–∞–µ—Ç–µ –Ω–∞–∏–±–æ–ª–µ–µ –≤–∞–∂–Ω—ã–º–∏?",
                    "answer": "–û–±—Å—É–¥–∏—Ç–µ —Ç–µ–∫—É—â–∏–µ –∏ –±—É–¥—É—â–∏–µ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏, –∏—Ö –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –∏–Ω–¥—É—Å—Ç—Ä–∏—é –∏ –≤–∞—à–µ –≤–∏–¥–µ–Ω–∏–µ —Ä–∞–∑–≤–∏—Ç–∏—è."
                },
                {
                    "question": "–ö–∞–∫ –≤—ã —Ä–µ—à–∞–µ—Ç–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –≤—ã–∑–æ–≤—ã?",
                    "answer": "–û–ø–∏—à–∏—Ç–µ –≤–∞—à –ø–æ–¥—Ö–æ–¥ –∫ —Å–ª–æ–∂–Ω—ã–º —Å–∏—Å—Ç–µ–º–Ω—ã–º —Ä–µ—à–µ–Ω–∏—è–º, —É—á–µ—Ç trade-offs –∏ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é."
                },
            ],
        }
        
        # Return fallback questions for the level
        return fallback_questions.get(level, fallback_questions['BEGINNER'])[:5]

    def _fix_truncated_json(self, truncated_str: str) -> str:
        """Fix common JSON truncation issues"""
        s = truncated_str.strip()
        
        # Remove trailing comma
        if s.endswith(','):
            s = s[:-1]
        
        # Fix unclosed arrays
        if s.count('[') > s.count(']'):
            diff = s.count('[') - s.count(']')
            s += ']' * diff
        
        # Fix unclosed objects
        if s.count('{') > s.count('}'):
            diff = s.count('{') - s.count('}')
            s += '}' * diff
        
        return s

